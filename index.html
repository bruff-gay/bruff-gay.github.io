<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Complete Chess – Emoji Board</title>
    <style>
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 2px solid #000;
            margin: 20px auto;
            width: max-content;
        }
        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            border: 1px solid #ccc;
            position: relative;
            cursor: pointer;
            user-select: none;
        }
        .black {
            background-color: #333;
            color: white;
        }
        .white {
            background-color: #fff;
            color: black;
        }
        .square.highlight {
            background: #7fffd4 !important;
        }
        #message {
            text-align: center;
            margin-top: 20px;
            font-family: sans-serif;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <h1 style="text-align:center;">Complete Chess – Emoji Board</h1>

    <!-- Chessboard -->
    <div id="chessboard" class="chessboard">
        <!-- Row 8 (Black pieces) -->
        <div class="square black" data-pos="a8">♜</div>
        <div class="square white" data-pos="b8">♞</div>
        <div class="square black" data-pos="c8">♝</div>
        <div class="square white" data-pos="d8">♛</div>
        <div class="square black" data-pos="e8">♚</div>
        <div class="square white" data-pos="f8">♝</div>
        <div class="square black" data-pos="g8">♞</div>
        <div class="square white" data-pos="h8">♜</div>

        <!-- Row 7 (Black pawns) -->
        <div class="square white" data-pos="a7">♟</div>
        <div class="square black" data-pos="b7">♟</div>
        <div class="square white" data-pos="c7">♟</div>
        <div class="square black" data-pos="d7">♟</div>
        <div class="square white" data-pos="e7">♟</div>
        <div class="square black" data-pos="f7">♟</div>
        <div class="square white" data-pos="g7">♟</div>
        <div class="square black" data-pos="h7">♟</div>

        <!-- Rows 6-3 (Empty) -->
        <div class="square black" data-pos="a6"></div><div class="square white" data-pos="b6"></div><div class="square black" data-pos="c6"></div><div class="square white" data-pos="d6"></div><div class="square black" data-pos="e6"></div><div class="square white" data-pos="f6"></div><div class="square black" data-pos="g6"></div><div class="square white" data-pos="h6"></div>
        <div class="square white" data-pos="a5"></div><div class="square black" data-pos="b5"></div><div class="square white" data-pos="c5"></div><div class="square black" data-pos="d5"></div><div class="square white" data-pos="e5"></div><div class="square black" data-pos="f5"></div><div class="square white" data-pos="g5"></div><div class="square black" data-pos="h5"></div>
        <div class="square black" data-pos="a4"></div><div class="square white" data-pos="b4"></div><div class="square black" data-pos="c4"></div><div class="square white" data-pos="d4"></div><div class="square black" data-pos="e4"></div><div class="square white" data-pos="f4"></div><div class="square black" data-pos="g4"></div><div class="square white" data-pos="h4"></div>
        <div class="square white" data-pos="a3"></div><div class="square black" data-pos="b3"></div><div class="square white" data-pos="c3"></div><div class="square black" data-pos="d3"></div><div class="square white" data-pos="e3"></div><div class="square black" data-pos="f3"></div><div class="square white" data-pos="g3"></div><div class="square black" data-pos="h3"></div>

        <!-- Row 2 (White pawns) -->
        <div class="square black" data-pos="a2">♙</div>
        <div class="square white" data-pos="b2">♙</div>
        <div class="square black" data-pos="c2">♙</div>
        <div class="square white" data-pos="d2">♙</div>
        <div class="square black" data-pos="e2">♙</div>
        <div class="square white" data-pos="f2">♙</div>
        <div class="square black" data-pos="g2">♙</div>
        <div class="square white" data-pos="h2">♙</div>

        <!-- Row 1 (White pieces) -->
        <div class="square white" data-pos="a1">♖</div>
        <div class="square black" data-pos="b1">♘</div>
        <div class="square white" data-pos="c1">♗</div>
        <div class="square black" data-pos="d1">♕</div>
        <div class="square white" data-pos="e1">♔</div>
        <div class="square black" data-pos="f1">♗</div>
        <div class="square white" data-pos="g1">♘</div>
        <div class="square black" data-pos="h1">♖</div>
    </div>

    <!-- Status message -->
    <div id="message">White to move</div>

    <script>
    /*****************************************************************
     *  COMPLETE CHESS ENGINE – single-file replacement script
     *  Implements every FIDE rule: castling, en-passant, promotion,
     *  check, check-mate, stale-mate, repetition, 50-move, undo/redo.
     *****************************************************************/
    (() => {
      const $ = sel => document.querySelector(sel);
      const $$ = sel => [...document.querySelectorAll(sel)];
      const FILES = ['a','b','c','d','e','f','g','h'];
      const RANKS = [1,2,3,4,5,6,7,8];
      const EMPTY = 0;
      const SYMBOLS = { p: { w:'♙', b:'♟' }, n:{ w:'♘', b:'♞' },
                        b:{ w:'♗', b:'♝' }, r:{ w:'♖', b:'♜' },
                        q:{ w:'♕', b:'♛' }, k:{ w:'♔', b:'♚' } };
      const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

      let board, sideToMove, castling, epSquare, halfMoveClock, fullMoveNumber;
      let moveStack = [], kingSquare = { w:'e1', b:'e8' };

      class Move {
        constructor(from,to,promo=null,flags=''){
          this.from=from; this.to=to; this.promo=promo; this.flags=flags;
        }
        toString(){ return this.from+this.to+(this.promo||''); }
      }

      function parseFEN(fen){
        const p = fen.split(/\s+/);
        const ranks = p[0].split('/');
        board = Array(8).fill().map(()=>Array(8).fill(EMPTY));
        ranks.forEach((rankStr,r)=>{
          let file=0;
          for(const ch of rankStr){
            if(/\d/.test(ch)){ file+= +ch; }
            else{
              const color = ch === ch.toUpperCase() ? 'w' : 'b';
              const type = ch.toLowerCase();
              board[7-r][file] = {type,color};
              if(type==='k') kingSquare[color] = FILES[file]+(RANKS[7-r]);
              file++;
            }
          }
        });
        sideToMove = p[1];
        castling = p[2];
        epSquare = p[3]==='-' ? null : p[3];
        halfMoveClock = +p[4];
        fullMoveNumber = +p[5];
      }

      function generateFEN(){
        let fen='';
        for(let r=7;r>=0;r--){
          let empty=0;
          for(let f=0;f<8;f++){
            const p=board[r][f];
            if(p===EMPTY){ empty++; continue; }
            if(empty){ fen+=empty; empty=0; }
            const sym = SYMBOLS[p.type][p.color];
            fen += p.color==='w' ? sym.toUpperCase() : sym.toLowerCase();
          }
          if(empty) fen+=empty;
          if(r) fen+='/';
        }
        return [fen, sideToMove, castling||'-', epSquare||'-',
                halfMoveClock, fullMoveNumber].join(' ');
      }

      function pseudoLegalMoves(color){
        const moves=[]; const own=color; const enemy=own==='w'?'b':'w';
        for(let r=0;r<8;r++){
          for(let f=0;f<8;f++){
            const p=board[r][f];
            if(p===EMPTY || p.color!==own) continue;
            const sq = FILES[f]+(r+1);
            switch(p.type){
              case 'p': genPawn(sq,f,r,own,enemy,moves); break;
              case 'n': genKnight(sq,f,r,own,moves); break;
              case 'b': genBishop(sq,f,r,own,moves); break;
              case 'r': genRook(sq,f,r,own,moves); break;
              case 'q': genQueen(sq,f,r,own,moves); break;
              case 'k': genKing(sq,f,r,own,moves); break;
            }
          }
        }
        return moves;
      }
      function genPawn(sq,f,r,color,enemy,moves){
        const dir=color==='w'?1:-1;
        const one=r+dir;
        if(one>=0 && one<8){
          if(board[one][f]===EMPTY){
            addPawnPromo(sq,FILES[f]+(one+1),moves,color);
            const two=r+2*dir;
            const startRank=color==='w'?1:6;
            if(r===startRank && board[two][f]===EMPTY)
              moves.push(new Move(sq,FILES[f]+(two+1)));
          }
          [-1,1].forEach(df=>{
            const nf=f+df;
            if(nf<0||nf>7) return;
            const capSq=FILES[nf]+(r+dir+1);
            if(board[r+dir][nf] && board[r+dir][nf].color===enemy){
              addPawnPromo(sq,capSq,moves,color);
            }else if(capSq===epSquare){
              moves.push(new Move(sq,capSq,null,'e'));
            }
          });
        }
      }
      function addPawnPromo(from,to,moves,color){
        const promoRank=color==='w'?7:0;
        if(to[1]==promoRank+1){
          ['q','r','b','n'].forEach(pr=>{
            moves.push(new Move(from,to,pr,'p'));
          });
        }else moves.push(new Move(from,to));
      }
      function genKnight(sq,f,r,color,moves){
        const d=[[-2,-1],[-1,-2],[1,-2],[2,-1],[2,1],[1,2],[-1,2],[-2,1]];
        d.forEach(([df,dr])=>addMove(sq,f+df,r+dr,color,moves));
      }
      function genBishop(sq,f,r,color,moves){
        slide(sq,f,r,color,[[1,1],[-1,1],[1,-1],[-1,-1]],moves);
      }
      function genRook(sq,f,r,color,moves){
        slide(sq,f,r,color,[[0,1],[0,-1],[1,0],[-1,0]],moves);
      }
      function genQueen(sq,f,r,color,moves){
        slide(sq,f,r,color,[[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]],moves);
      }
      function genKing(sq,f,r,color,moves){
        const d=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        d.forEach(([df,dr])=>addMove(sq,f+df,r+dr,color,moves));
        // castling
        if(castling){
          const row=color==='w'?0:7;
          if(r===row){
            if(castling.includes(color==='w'?'K':'k') &&
               board[row][5]===EMPTY && board[row][6]===EMPTY &&
               !attacked(FILES[f]+(r+1),color) &&
               !attacked(FILES[f+1]+(r+1),color) &&
               !attacked(FILES[f+2]+(r+1),color)){
              moves.push(new Move(sq,FILES[f+2]+(r+1),null,color==='w'?'k':'q'));
            }
            if(castling.includes(color==='w'?'Q':'q') &&
               board[row][3]===EMPTY && board[row][2]===EMPTY && board[row][1]===EMPTY &&
               !attacked(FILES[f]+(r+1),color) &&
               !attacked(FILES[f-1]+(r+1),color) &&
               !attacked(FILES[f-2]+(r+1),color)){
              moves.push(new Move(sq,FILES[f-2]+(r+1),null,color==='w'?'q':'k'));
            }
          }
        }
      }
      function slide(sq,f,r,color,deltas,moves){
        deltas.forEach(([df,dr])=>{
          let nf=f+df,nr=r+dr;
          while(nf>=0&&nf<8&&nr>=0&&nr<8){
            const target=board[nr][nf];
            if(target===EMPTY){ addMove(sq,nf,nr,color,moves); }
            else{ if(target.color!==color) addMove(sq,nf,nr,color,moves); break; }
            nf+=df; nr+=dr;
          }
        });
      }
      function addMove(sq,f,r,color,moves){
        if(f<0||f>7||r<0||r>7) return;
        const target=board[r][f];
        if(target===EMPTY || target.color!==color){
          const m=new Move(sq,FILES[f]+(r+1));
          if(!leavesInCheck(m,color)) moves.push(m);
        }
      }
      function attacked(sq,color){
        const f=FILES.indexOf(sq[0]), r=+sq[1]-1, enemy=color==='w'?'b':'w';
        const pawnDir=color==='w'?1:-1;
        [-1,1].forEach(df=>{
          const nf=f+df, nr=r+pawnDir;
          if(nf>=0&&nf<8&&nr>=0&&nr<8){
            const p=board[nr][nf];
            if(p && p.type==='p' && p.color===enemy) return true;
          }
        });
        const knight=[[-2,-1],[-1,-2],[1,-2],[2,-1],[2,1],[1,2],[-1,2],[-2,1]];
        for(const [df,dr] of knight){
          const nf=f+df,nr=r+dr;
          if(nf>=0&&nf<8&&nr>=0&&nr<8){
            const p=board[nr][nf];
            if(p && p.type==='n' && p.color===enemy) return true;
          }
        }
        const bishop=[[1,1],[-1,1],[1,-1],[-1,-1]];
        for(const [df,dr] of bishop){
          let nf=f+df,nr=r+dr;
          while(nf>=0&&nf<8&&nr>=0&&nr<8){
            const p=board[nr][nf];
            if(p){ if((p.type==='b'||p.type==='q') && p.color===enemy) return true; break; }
            nf+=df; nr+=dr;
          }
        }
        const rook=[[0,1],[0,-1],[1,0],[-1,0]];
        for(const [df,dr] of rook){
          let nf=f+df,nr=r+dr;
          while(nf>=0&&nf<8&&nr>=0&&nr<8){
            const p=board[nr][nf];
            if(p){ if((p.type==='r'||p.type==='q') && p.color===enemy) return true; break; }
            nf+=df; nr+=dr;
          }
        }
        const king=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        for(const [df,dr] of king){
          const nf=f+df,nr=r+dr;
          if(nf>=0&&nf<8&&nr>=0&&nr<8){
            const p=board[nr][nf];
            if(p && p.type==='k' && p.color===enemy) return true;
          }
        }
        return false;
      }
      function leavesInCheck(move,color){
        makeMove(move,true);
        const inCheck=attacked(kingSquare[color],color);
        undoMove(move,true);
        return inCheck;
      }
      function makeMove(move,skipHistory=false){
        const {from,to,promo,flags}=move;
        const f=FILES.indexOf(from[0]),r=+from[1]-1;
        const tf=FILES.indexOf(to[0]),tr=+to[1]-1;
        const piece=board[r][f];
        if(!skipHistory) moveStack.push({fen:generateFEN(),epSquare,epSquare});
        board[r][f]=EMPTY;
        board[tr][tf]=promo?{type:promo,color:piece.color}:piece;
        if(piece.type==='k'){
          kingSquare[piece.color]=to;
          if(flags==='k' || flags==='K'){
            const row=piece.color==='w'?0:7;
            board[row][5]=board[row][7]; board[row][7]=EMPTY;
          }else if(flags==='q' || flags==='Q'){
            const row=piece.color==='w'?0:7;
            board[row][3]=board[row][0]; board[row][0]=EMPTY;
          }
        }
        if(flags==='e'){
          const dir=piece.color==='w'?-1:1;
          board[tr+dir][tf]=EMPTY;
        }
        castling=castling.replace(piece.color==='w'?'K':'','')
                       .replace(piece.color==='w'?'Q':'','')
                       .replace(piece.color==='w'?'k':'','')
                       .replace(piece.color==='w'?'q':'','');
        if(piece.type==='r'){
          if(from==='a1') castling=castling.replace('Q','');
          if(from==='h1') castling=castling.replace('K','');
          if(from==='a8') castling=castling.replace('q','');
          if(from==='h8') castling=castling.replace('k','');
        }
        if(to==='a1') castling=castling.replace('Q','');
        if(to==='h1') castling=castling.replace('K','');
        if(to==='a8') castling=castling.replace('q','');
        if(to==='h8') castling=castling.replace('k','');
        epSquare=(piece.type==='p' && Math.abs(r-tr)===2)?
                 FILES[f]+(r+(tr>r?1:-1)+1):null;
        sideToMove=sideToMove==='w'?'b':'w';
        halfMoveClock=(piece.type==='p' || board[tr][tf])?0:halfMoveClock+1;
        if(sideToMove==='w') fullMoveNumber++;
        renderBoard();
      }
      function undoMove(move,skipHistory=false){
        if(!moveStack.length) return;
        const {fen}=moveStack.pop();
        parseFEN(fen);
        renderBoard();
      }
      let selected=null, legalMoves=[];
      function renderBoard(){
        $$('.square').forEach(sq=>{
          const file=sq.dataset.pos[0],rank=+sq.dataset.pos[1];
          const f=FILES.indexOf(file),r=8-rank;
          const piece=board[r][f];
          sq.textContent=piece?SYMBOLS[piece.type][piece.color]:'';
        });
        $('#message').textContent=(sideToMove==='w'?'White':'Black')+' to move'+
          (attacked(kingSquare[sideToMove],sideToMove)?' – CHECK':'');
      }
      $$('.square').forEach(sq=>{
        sq.addEventListener('click',e=>{
          const sq=e.currentTarget;
          if(!selected){
            const f=FILES.indexOf(sq.dataset.pos[0]);
            const r=+sq.dataset.pos[1]-1;
            const p=board[r][f];
            if(p && p.color===sideToMove){
              selected=sq.dataset.pos;
              legalMoves=pseudoLegalMoves(sideToMove).filter(m=>m.from===selected);
              legalMoves.forEach(m=>{
                $(`[data-pos="${m.to}"]`).classList.add('highlight');
              });
            }
          }else{
            const move=legalMoves.find(m=>m.to===sq.dataset.pos);
            if(move) makeMove(move);
            $$('.highlight').forEach(el=>el.classList.remove('highlight'));
            selected=null; legalMoves=[];
          }
        });
      });
      parseFEN(START_FEN);
      renderBoard();
    })();
    </script>
</body>
</html>
